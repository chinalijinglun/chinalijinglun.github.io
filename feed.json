{"title":"李经纶HEXO博客","description":"您好，我是李经纶，这是我个人博客，用来记录我的一些学习跟成长的过程。分享一些包括但不限于交互、页面制作、前端开发等方面的知识。","language":"zh-cn","link":"https://chinalijinglun.github.io","pubDate":"Fri, 24 Feb 2023 07:43:35 GMT","lastBuildDate":"Mon, 06 Mar 2023 08:50:34 GMT","generator":"hexo-generator-json-feed","webMaster":"李经纶","items":[{"title":"聊聊前端优化","link":"https://chinalijinglun.github.io/2023/02/24/聊聊前端优化/","description":"随着互联网技术的发展，网页已经不再是简单的静态文档，而是变成了功能丰富、交互复杂、视觉精美的应用程序。然而，这些应用程序也带来了一个挑战：如何在保证功能和体验的同时，让网页快速加载并运行？这就是前端性能优化要解决的问题。 前端性能优化是一门综合性很强的学科，它涉及到网络、浏览器、JavaScript、CSS、HTML、图片等多个方面。为了达到最佳效果，我们需要从多个角度出发，采用各种技巧和工具来分析、测试、监控和改进网页的性能。 本文旨在提供一份全面而实用的前端性能优化指南。（本段文字来自chatGPT生成） 以上来自雅虎优化指南，也叫雅虎军规。 服务端篇 Content Delivery Network（CDN） cdn具有能提高网站的访问速度、节省带宽等优势，其工作原理是通过将源站的内容缓存到分布在不同地区和运营商的边缘节点上，当用户请求时，就近返回节点上缓存的内容。cdn还涉及DNS解析、负载均衡、内容分发、调度等技术模块。 浏览器缓存 缓存的设置可以大大提高响应速度，减少http请求，节省带宽等优势，缓存包括强缓存、协商缓存等，可以添加Expires头，配置ETag等属性来选择缓存的方式。当浏览器请求一个资源时，它会检测本地缓存中是否有该资源，并且是否在有效期内，如果是，则直接从本地缓存中返回该资源。 强缓存是利用HTTP请求头中的Expires和Cache-Control 两个字段来进行控制，用来表示资源的缓存时间，Expires是一个绝对时间，Cache-Control 是一个相对时间，表示资源在多长时间内有效；一般会对js、css、图片等资源使用强缓存。 协商缓存是利用 HTTP 请求头中的 Last-Modified/If-Modified-Since 和 ETag/If-None-Match 两对字段来进行控制，用来表示资源的更新时间和唯一标识。 当浏览器再次请求一个资源时，如果本地缓存已经过期，它会携带这些字段向服务器发送请求，询问资源是否有更新。如果没有更新，则服务器会返回 304 状态码，告诉浏览器可以继续使用本地缓存。如果有更新，则服务器会返回 200 状态码和新的资源，并更新本地缓存。 AppCache 在html页面中指定manifest文件的路径，例如&lt;html manifest=&quot;example.appcache&quot;&gt; 在manifest文件中列出需要缓存的资源，以及在离线时显示的页面，例如： 1234567891011121314CACHE MANIFEST# v1.0.0CACHE:index.htmlstyle.cssscript.jslogo.pngNETWORK:*FALLBACK:/ offline.html 在服务器端配置正确的MIME类型，例如text/cache-manifest 在浏览器中访问html页面，浏览器会自动下载并缓存manifest文件中指定的资源 在离线时，浏览器会从缓存中加载资源，并在无法访问的情况下显示fallback页面 Localstorge、Sessionstorage、Cookie、CacheStorage 用于本地存储，常用，不必过多解释。 减少请求数 小图片合并雪碧图； 避免重复的资源请求。减少请求数 减少文件大小，节省请求带宽 压缩CSS、JS、图片； 尽可能控制DOM节点数； 精简css、 JavaScript，移除注释、空格、重复css和脚本。 开启Gzip，Gzip的思想就是把文件先在服务器端进行压缩，且压缩率达到85%，然后再传输，传输完毕后浏览器会重新对压缩过的内容进行解压缩，并执行。。好处在于Gzip的支持已经很好，且爬虫可识别，压缩率达到66%-85%显著减少了文件传输的大小。另外，gzip对pdf文件的压缩效果不大，而且会浪费CPU。 静态资源域名 域名的要求一般是独立短小，短小可以减少头部开销，域名越短请求头的URI就越短；独立是因为独立的域名不会共享主域的cookie，可以减少请求头大小，还有一个原因是浏览器对相同域名的并发连接数是有限制的，一般同域名为6-8个连接，当然域名不是越多越好，每个域名的第一次连接都要经理DNS查询，会耗费时间，尽量控制域名在2-4个间，需要注意的是，同一静态资源在不同页面散列到不同子域下，会导致无法利用http缓存。 http2（来源：baidu.com） 多路复用：多路复用很好地解决如何让重要资源尽快加载这个问题。同域名下或者不同域但是同时满足同一个 IP以及使用同一个证书的这两个条件中的所有通信都在单个连接上完成，此连接上同时打开任意数量的双向数据流（ HTTP 1.1 有连接数限制）。使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。（来源：baidu.com） HEAD压缩：HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码（ Binary Framing ）。在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成，状态行和头部却没有经过任何压缩，直接以纯文本传输。在 HTTP/2 中，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。 请求优先级：服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。 服务器推送：启动Server Push，意味着服务端可以在发送页面HTML时主动推送其它资源，有自己独立的URL，可以被浏览器缓存；如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。 客户端篇 使用外链CSS和JS，CSS放头，JS放尾，防止阻塞以减少对并发下载的影响，尽早刷新文档的输出。 html的代码优化，如： 避免空的图片src； 协议自适应，减少html文件大小，将https://和http://都替换成//。 css的代码优化，如： 建议使用类选择器，访问比较快； 不建议使用很长的base64； 避免CSS表达式； 避免使用Filters。 js的代码优化，如： 避免使用eval和width； 减少作用域链查找； 减少DOM访问，尽量缓存DOM； 充分利用事件委托； 减少Repaint（重绘）和Reflow（重排）最好通过批量更新元素减少重排次数，如设置类class统一更新样式，在添加多个li 元素将会触发多次页面重排的情况下使用 DOM fargment 在内存中创建完整的 DOM 节点，然后再一次性添加到 DOM 中。 图片格式的选择： 颜色较为丰富的图片而且文件比较大的（40KB - 200KB）或者有内容的图片优先考虑 jpg；图标等颜色比较简单、文件体积不大、起修饰作用的图片，优先考虑使用 PNG8 格式；图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式。 条件允许的，使用新格式WEBP和BPG。 用SVG和ICONFONT代替简单的图标。 合理分配资源加载时间，按需加载，包括CSS、JS文件以及图片、业务模块等。 根据我们网页最初加载需要的最小内容集推断其他内容延迟加载；无条件提前加载公共内容或根据用户行为推断提前加载某些内容，如根据搜索框输入的文字来判断加载的内容。加载机制如下： 预加载 Dom Ready后加载 onLoad后加载 滚动加载 减少DNS 查询：DNS 查询一般需要几毫秒到几百毫秒，移动环境下会更慢。我们可以预先读取DNS，减少用户等待时间。 更多代码规范相关，请参考： 前端代码规范","pubDate":"Fri, 24 Feb 2023 07:43:35 GMT","guid":"https://chinalijinglun.github.io/2023/02/24/聊聊前端优化/","category":"性能优化"},{"title":"antd中表单自定义组件如何获取值","link":"https://chinalijinglun.github.io/2023/02/22/表单自定义组件/","description":"页面中有大量的form表单，但是不是所有的自定义表单都能满足我们的需求，很有可能需要自定义组件去解决问题，那么自定义组件如何获取antd的value值呢？12345678910111213141516171819202122232425262728import &#123; Form, Input &#125; from 'antd';import &#123; useEffect &#125; from 'react'; const App = () =&gt; &#123; const [form]= Form.useForm(); useEffect(() =&gt; &#123; form.setFieldsValue(&#123; a: &#123; b: &#123; c: 'ccc' &#125; &#125;, d: &#123; e : 'eee' &#125; &#125;) &#125;, []); return ( &lt;Form form=&#123;form&#125;&gt; &lt;Form.Item name=&#123;['d', 'e']&#125;&gt; &lt;Input/&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )&#125;export default App; 这代码熟悉吧！是不是经常写？ 这是 antd 的 Form 组件的用法： 通过 useForm 拿到 form 对象，设置到 Form 组件里，然后用 form.setFieldsValue 设置的字段值就能在 Form.Item 里取到。 Form.Item 只需要在 name 里填写字段所在的路径就行，也就是 [‘d’, ‘e’] 这个。 有的同学可能会问了，为啥这里只设置了个 name，它下面的 Input 就有值了呢？ 我们让 Form.Item 渲染一个自定义的组件试一下，比如这样： 12345const MyInput = (props) =&gt;&#123; return &lt;div&gt; &lt;Input&gt; &lt;/div&gt; &#125; 1234567return ( &lt;Form form=&#123;form&#125;&gt; &lt;Form.Item name=&#123;['d', 'e']&#125;&gt; &lt;MyInput/&gt; &lt;/Form.Item&gt; &lt;/Form&gt;) 通过给自定义组件打断点，可以看到，组件内部传入了 id、value、onChange 等参数进来， 这就是为啥 Input 能有值，因为传入了 value 参数。 而且变化了也能同步到 fields，因为传入了 onChange 参数。 有的时候我们要对保存的值做一些修改，就可以这样写： 12345678function MyInput(props) &#123; const &#123; value, onChange &#125; = props; console.log(form.getFieldsValue()) function onValueChange(event) &#123; onChange(event.target.value.toUpperCase()); &#125; return &lt;Input value=&#123;value&#125; onChange=&#123;onValueChange&#125;&gt;&lt;/Input&gt;&#125; 所以说，Form.Item 会给子组件传入 value、onChange 参数用来设置值和接受值的改变，同步到 form 的 fields。 以下是我个人经常使用的上传图片的组件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; useEffect, useState &#125; from 'react'import &#123; message, Upload &#125; from \"antd\";import &#123; LoadingOutlined, PlusOutlined &#125; from \"@ant-design/icons\";const defaultUrl = \"\"const imageURL = \"\"const UploadImg = (props: any) =&gt; &#123; const &#123;value, onChange&#125; = props; const [loading, setLoading] = useState(false); const handleChange = (info: any) =&gt; &#123; if (info.file.status === \"uploading\") &#123; setLoading(true); return; &#125; if (info.file.status === \"done\") &#123; const url = info.file.response.data.url; onChange &amp;&amp; onChange(url); setLoading(false); &#125; &#125;; const beforeUpload = (file: any) =&gt; &#123; const isJpgOrPng = file.type === \"image/jpeg\" || file.type === \"image/png\"; if (!isJpgOrPng) &#123; message.error(\"只支持 JPG/PNG 文件!\"); &#125; const isLt2M = file.size / 1024 / 1024 &lt; 5; if (!isLt2M) &#123; message.error(\"图片必须小于5MB!\") &#125; return isJpgOrPng &amp;&amp; isLt2M; &#125;; return ( &lt;Upload name=\"file\" // customRequest=&#123;customRequest&#125; listType=\"picture-card\" className=\"avatar-uploader\" showUploadList=&#123;false&#125; action=&#123;defaultUrl&#125; beforeUpload=&#123;beforeUpload&#125; onChange=&#123;handleChange&#125; &gt; &#123;value ? ( &lt;img src=&#123;imageURL + value&#125; alt=\"avatar\" style=&#123;&#123; width: \"100%\" &#125;&#125; /&gt; ) : ( &lt;div&gt; &#123;loading ? &lt;LoadingOutlined /&gt; : &lt;PlusOutlined /&gt;&#125; &lt;div style=&#123;&#123; marginTop: 8 &#125;&#125;&gt;点击上传&lt;/div&gt; &lt;/div&gt; )&#125; &lt;/Upload&gt; )&#125;export default UploadImg","pubDate":"Wed, 22 Feb 2023 07:43:35 GMT","guid":"https://chinalijinglun.github.io/2023/02/22/表单自定义组件/","category":"react开发"},{"title":"Phaser游戏开发2","link":"https://chinalijinglun.github.io/2018/05/03/Phaser游戏开发2/","description":"Phaser游戏开发2； 上面的代码已经完成了80%的内容，下面让我们来继续完善游戏内容； 碰撞检测1game.physics.arcade.collide(player, platforms); Phaser.Physics.arcade.collide(object1, object2, collideCallback, processCallback, callbackContext) 参数分别为，对象1，对象2，碰撞回调函数，比如有的关卡，有陷阱一类的，人物要是碰撞后，在回调中kill人物，state跳到over上。 重叠检测跟碰撞类似，只是api不同1game.physics.arcade.overlap(player, platforms); Phaser.Physics.arcade.overlap(object1, object2, collideCallback, processCallback, callbackContext) 多用在获得道具上，比如人物和星星重叠后，可以加分，然后消除星星。 12345game.physics.arcade.overlap(player,stars,function (player,star) &#123; scroe += 10; fonts.text = 'scroe: ' + scroe; star.kill();&#125;) 上下左右操作1cursors = game.input.keyboard.createCursorKeys(); Phaser.Game.input.keyboard.createCursorKeys() 1234567891011if(cursors.left.isDown)&#123; player.body.velocity.x = -150; player.animations.play('left');&#125;else if(cursors.right.isDown)&#123; player.body.velocity.x = 150; player.animations.play('right');&#125;else&#123; player.frame = 4; player.body.velocity.x = 0; player.animations.stop();&#125; 当按下键盘 &lt;- 左键时，x轴加速为-150，然后执行animations的left动画，有一点是需要注意的是，在没有按下左右键的时候，让frame定格在第4帧，1player.frame = 4; 以下为全部代码：Phaser 小游戏About。","pubDate":"Thu, 03 May 2018 07:45:09 GMT","guid":"https://chinalijinglun.github.io/2018/05/03/Phaser游戏开发2/","category":"游戏开发"},{"title":"Phaser游戏开发1","link":"https://chinalijinglun.github.io/2018/04/27/Phaser游戏开发/","description":"最近开发基于微信分享的h5小游戏，之前试用createJs，觉得想换个游戏引擎试试，所以找到了Phaser，基于pixi，内置了物理引擎，动画等。 初始化123456789var game = new Phaser.Game(288,505,Phaser.AUTO,'game',state); var game = new Phaser.Game(288,505,Phaser.AUTO,'game',&#123;proload:proload,create:create&#125;);Phaser.Game(width, height, renderer, parent, state, transparent, antialias, physicsConfig)width: 游戏场景的宽度，单位为pxheight: 高度，renderer: 渲染方式，有Phaser.CANVAS，Phaser.WebGL，Phaser.AUTO，auto是自动识别parent: 用来放置canvas元素的父元素，可以是一个元素id，也可以是dom元素本身，phaser会自动创建一个canvas并插入到这个元素中state: 场景，通常会有（init，proload，create，update等） state 是一个场景，可以是一个对象，也可以是一个构造函数，只要存在proload、create、update中的一个，就是一个合法的state； 1234567891011121314151617181920//state可以是一个自定义对象var state1 = &#123; preload : function()&#123; &#125;, create : function()&#123; &#125;, update : function()&#123; &#125; &#125;//state也可以是一个构造函数var state2 = function()&#123; this.preload = function()&#123; &#125;; this.create = function()&#123; &#125;; this.update = function()&#123; &#125;;&#125;//state里面可以存在其他的方法，和属性//state里面只要存一个proload、create、update中一个即可var state3 = function()&#123; this.aaa = function()&#123;&#125;; this.bbb = 'first'; this.create=function()&#123;&#125;&#125; 加载资源proload函数是最先执行的，用来加载资源、create是初始化场景的函数，等proload执行完成后执行，update是更新函数，游戏每一帧都要执行update； 12345678910function state() &#123; //加载资源 this.preload = function () &#123; // load img and 精灵 game.load.image(&quot;sky&quot;, &apos;assets/sky.png&apos;); game.load.image(&quot;platform&quot;, &apos;assets/platform.png&apos;); game.load.image(&quot;star&quot;, &apos;assets/star.png&apos;); game.load.spritesheet(&apos;dude&apos;, &quot;assets/dude.png&quot;, 32, 48); &#125;&#125; 使用方法为:game.load.’资源’(‘别名’,’路径’)；常用的资源有：image、audio、tilemap、text、spritesheet；别名指后面用的名称；其中spritesheet还需要添加每帧的宽高帧数等。 初始界面资源加载完成后，会自动进入create函数123this.create = function () &#123; game.add.sprite(0,0,'sky')&#125; sprite对象，也叫精灵，可以用图片来创建精灵，然后用phaser提供的属性，来操作。1game.add.sprite(0,0,'sky') 创建后，会自动添加对应的内容在主界面。说一个比较重要的对象：Phaser.group(),也就是组，相当于一个统一一个父容器，把需要的子对象放进去，然后可以通过组的方法进行批量的操作，比如统一的位移和碰撞检测等。12345platforms = game.add.group();var ground = platforms.create(0,0,'platform');var ledge = platforms.create(400,200,'platform'); 物理引擎Phaser已支持一些不同的物理系统，有Arcade Physics,，Ninja Physics 和 P2.JS Full-Body Physics。对与简单的物理方法，我们使用Arcade Physics即可。物理引擎在Phaser中是默认关闭的，要启用可以在create中使用：1game.physics.startSystem(Phaser.Physics.ARCADE); 要启用整组的物理属性，使用enableBody即可1platforms.enableBody = true; 开启物理属性后，即可得到一个body属性，所有的物理属性方法都挂在body上面常用的属性有：immovable、bounce、gravity、drag、sprite、x、y、collideWorldBounds、input等，对应各种固定，弹性、重力，拖拽，边界等。 12ground.body.immovable = true;legs.body.immovable = true; 12player.animations.add(&apos;left&apos;, [0, 1, 2, 3], 10, true);player.animations.add(&apos;right&apos;, [5, 6, 7, 8], 10, true); TileSprite、Rope、Image、Button、Sprite等拥有animations属性，可以添加动画方法1Phaser.Sprite.animations.add(name, frames, frameRate, loop, useNumericIndex) 分别为动画名称，帧数数组，每秒帧数，循环次数； 添加文字1game.add.text(10,10,'score:0',&#123; font: \"35px Arial\", fill: \"#ff0044\"&#125;) //Phaser.Game.add.text(x, y, text, style, group);如果你经常使用canvas的话，对这种应该不陌生，分别为：x、y、文字内容，样式组。 这样我们基本完成了create函数的内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748this.create=function () &#123; //开启物理引擎 game.physics.startSystem(Phaser.Physics.ARCADE); //添加天空 game.add.sprite(0, 0, 'sky'); //添加地板组 platforms = game.add.group(); //开启地板组的物理属性 platforms.enableBody = true; //添加底部地板 var grounds = platforms.create(0,game.world.height-32,'platform'); //设置缩放 grounds.scale.setTo(2,1); //禁止移动 grounds.body.immovable = true; var legs = platforms.create(-150,120,'platform'); legs.body.immovable = true; legs = platforms.create(400,270,'platform'); legs.body.immovable = true; //添加人物 player = game.add.sprite(32, 150, 'dude'); game.physics.arcade.enable(player); player.body.bounce.y = 0.3; player.body.gravity.y = 500; player.body.collideWorldBounds = true; player.animations.add('left', [0, 1, 2, 3], 10, true); player.animations.add('right', [5, 6, 7, 8], 10, true); cursors = game.input.keyboard.createCursorKeys(); //添加文字 fonts = game.add.text(10,10,'score:0',&#123; font: \"35px Arial\", fill: \"#ff0044\"&#125;) //添加星星 stars = game.add.group(); stars.enableBody = true; for(var i =0;i&lt;12;i++)&#123; var star = stars.create(i * 70 , 0, 'star'); star.body.bounce.y = 0.7; star.body.gravity.y = 400; star.body.collideWorldBounds = true; &#125; &#125;","pubDate":"Fri, 27 Apr 2018 09:06:30 GMT","guid":"https://chinalijinglun.github.io/2018/04/27/Phaser游戏开发/","category":"游戏开发"},{"title":"iTerm2 免密登录 SSH 的方法","link":"https://chinalijinglun.github.io/2018/04/27/登录/","description":"大家都知道使用iTerm2连接shh 使用命令 ssh -p22 root@129.10.10.1，然后输入密码即可。但是对于我们的服务器或者测试服务器，每次都这么手动ssh连接太慢了而且麻烦，我们可以考虑使用比较快捷的方式去连接的。 1、在~/.ssh下，新建文件，比如login，或者test1等；2、1234567891011#!/usr/bin/expect -fset user rootset host 192.168.1.109set password test123###set timeout -1spawn ssh $user@$hostexpect \"*assword:*\"send \"$password\\r\"interactexpect eof 3、如果是其他的端口，在set一个port xxxx，xxxx对应你的端口；4、打开iterm2的Profiles，点击+号，新增一个profile，name写自己连接主机的名称，然后在command上选择command，把：1expect ~/.ssh/login 后面的login对应你建立的文件名称5、使用的时候，直接在iterm2上面的Profiles选择你填写的用户名即可。","pubDate":"Fri, 27 Apr 2018 06:50:59 GMT","guid":"https://chinalijinglun.github.io/2018/04/27/登录/","category":"Web开发"},{"title":"新年新展望","link":"https://chinalijinglun.github.io/2018/01/15/新年新展望/","description":"“又是一年芳草绿,春风十里杏花香”总结一下去年的自己，去年自己算是挺圆满的了，结了个婚，换了份工作，虽然不是什么大人物，但是小人物也有小人物的幸福，挺知足的。去年自己成功的把vueJs引入上家公司，并完成了前后端的完全分离，极大的解放了生产力和提高了效率，并使得公司绝大部分人都学习了vue及nodejs，并使用vue开发了3、4个大型的项目，对vue也算是从熟悉到理解，并能够把element-ui中的组件重写或者更改；项目中也使用了很多ES6的语法，对ES6也算是很熟悉了吧。看了将近20本左右的书籍，其中文学读物（金庸、古龙、梁羽生、四大名著、网络小说）占比一半，技术书籍（js、python、nodejs、css）占一半，总体来说，看书的收获还是挺大的，希望自己有一天也能出书。 又是一年的开始，做个今年的计划吧！1、写完自己的vueUI组件，传说中的Lui，哈哈2、写go程序或者python，毕竟很久没写了3、写一款自己的小游戏4、精通typescript5、看完10左右的技术书籍","pubDate":"Mon, 15 Jan 2018 07:12:32 GMT","guid":"https://chinalijinglun.github.io/2018/01/15/新年新展望/","category":"随笔"},{"title":"canvas压缩图片","link":"https://chinalijinglun.github.io/2017/08/06/canvas压缩图片/","description":"最近遇到了图片压缩的问题，想在前端控制一下，所以有了一下代码。","pubDate":"Sun, 06 Aug 2017 10:45:41 GMT","guid":"https://chinalijinglun.github.io/2017/08/06/canvas压缩图片/","category":"Web开发"},{"title":"chrome下调试小技巧（一）","link":"https://chinalijinglun.github.io/2017/07/24/chrome_1/","description":"chrome下调试小技巧（一） 1、快速格式化线上压缩的js和css我们通常看线上的js或者css都是这样的 通过在sources下的{}，点击即可格式化代码很方便 2、在浏览器中储存你的代码段其实chrome中也是可以储存我们自己的代码的，如果不想每次都粘贴在控制台中或者临时想写些什么，那么sources中的Sinppets将是你的一个很好的选择，Sinppets中你可以新建很多个不同的代码段，跟文本一样，可以写一些文字或者代码，可以command+s保存，如果你写的是js代码一类的，可以直接右键你的Sinppets文件名称，点击Run，即可执行你的代码，也可以右键文件Save as保存文件到本地。 3、快速定位到指定的文件或者文件中的方法ctrl+p 项目中定位文件，以下查找VueJS库文件：ctrl+shif+o 文件中定位成员函数，以下定位到VueJS的nextTick接口： 暂且写这么多，network及短点什么的，估计大家都会用了，就不介绍了。","pubDate":"Mon, 24 Jul 2017 09:52:37 GMT","guid":"https://chinalijinglun.github.io/2017/07/24/chrome_1/","category":"移动开发"},{"title":"Hello World","link":"https://chinalijinglun.github.io/2015/10/08/hello-world/","description":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Thu, 08 Oct 2015 02:24:35 GMT","guid":"https://chinalijinglun.github.io/2015/10/08/hello-world/","category":"Web开发"}]}