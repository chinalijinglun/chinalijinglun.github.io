{"title":"李经纶HEXO博客","description":"您好，我是李经纶，这是我个人博客，用来记录我的一些学习跟成长的过程。分享一些包括但不限于交互、页面制作、前端开发等方面的知识。","language":"zh-cn","link":"https://chinalijinglun.github.io","pubDate":"Fri, 30 Aug 2024 07:09:20 GMT","lastBuildDate":"Mon, 02 Sep 2024 10:56:09 GMT","generator":"hexo-generator-json-feed","webMaster":"李经纶","items":[{"title":"cloudflare的代理","link":"https://chinalijinglun.github.io/2024/08/30/cloudflare的代理/","description":"【引言】cloudflare对于我们开发者来说，应该并不陌生，和vercel类似，人称”赛博菩萨”，因为它对开发者提供了很多免费的工具和服务来提升网站的安全性、性能、稳定性，今天不去介绍什么是正向代理，什么是反向代理，有兴趣的可以自行搜索，今天主要是分享如何通过cloudflare的worker部署一个正向代理访问github一类网站的工具。【前提】域名（必备cloudflare账号（必备【绑定域名到cloudflare】 步骤1：在cloudflare首页中选择添加域 步骤2：输入你的域名 步骤3：选择免费版本 步骤4：修改域名的DNS 步骤5：以我阿里云域名为例，在域名管理里面选择DNS修改 步骤6：输入步骤4的DNS后，验证手机号码，一路确定就行了 步骤7：在cloudflare中继续操作，HTTPS都选择是就行。 步骤8：等待解析就行，一般不会太久，完成后会有邮件提醒，或者列表状态变更。 【部署worker】 步骤1：在cloudflare中的侧边栏Workers和Pages中，选择创建。 步骤2：创建worker 步骤3：里面为默认代码, 可以使用下面代码 12345678910export default &#123; async fetch(request) &#123; const url = new URL(request.url); //被正向代理的域名或者ip:端口号 url.host = 'github.com'; return fetch(url, &#123; headers: request.headers, method: request.method, body: request.body &#125;); &#125;,&#125;; 步骤4：点击部署后，可以访问cloudflare分配给你的域名，如果访问不通，那么我就要把我们绑定cloudflare的域，添加到worker，可以随意添加你命名的二级域名，绑定成功后，等待自定义域生效，然后访问自己的二级域名，就实现了不用翻墙即可打开github等操作，切可登录。 【后续】 其实worker能做到的事情很多，上面只写了简单的代理，其实里面还可以把上面的请求内容细化，包括一些image、js、接口请求的重定向等；还可以自定义cookie，header等内容；通过worker其实可以把别人的网站，分分钟转移到自己的上面，还能修改内容。 PS： 后续可以聊聊Pages，也是非常有意思，除了能做静态网站托管外，还可以搭建属于自己的梯子。","pubDate":"Fri, 30 Aug 2024 07:09:20 GMT","guid":"https://chinalijinglun.github.io/2024/08/30/cloudflare的代理/","category":"工具"},{"title":"react中useImperativeHandle的使用","link":"https://chinalijinglun.github.io/2024/08/16/react中useImperativeHandle的使用/","description":"【引言】页面中经常会有写全局的Modal、Alert、Toast、Login、等组件，这些组件通常会被用到很多页面中，如果每个页面都写一个Modal、Alert、Toast、Login、等组件，看起来不够美观，也不利于代码的维护。通过执行方法，即可调用全局的组件，而不需要每个页面都写一个Modal、Alert、Toast、Login、等组件。 【实现1】子组件1234567891011121314151617import React, &#123; useImperativeHandle, forwardRef, useRef &#125; from 'react';const ChildComponent = forwardRef((props, ref) =&gt; &#123; const inputRef = useRef(); // 使用 useImperativeHandle 自定义暴露给父组件的实例值 useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); // 暴露 focus 方法 &#125;, getValue: () =&gt; &#123; return inputRef.current.value; // 暴露获取输入值的方法 &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; type=\"text\" /&gt;;&#125;); 父组件 123456789101112131415161718192021222324import React, &#123; useRef &#125; from 'react';import ChildComponent from './ChildComponent';const ParentComponent = () =&gt; &#123; const childRef = useRef(); const handleFocus = () =&gt; &#123; childRef.current.focus(); // 调用子组件的 focus 方法 &#125;; const handleGetValue = () =&gt; &#123; console.log(childRef.current.getValue()); // 获取子组件的输入值 &#125;; return ( &lt;div&gt; &lt;ChildComponent ref=&#123;childRef&#125; /&gt; &lt;button onClick=&#123;handleFocus&#125;&gt;Focus Input&lt;/button&gt; &lt;button onClick=&#123;handleGetValue&#125;&gt;Get Input Value&lt;/button&gt; &lt;/div&gt; );&#125;;export default ParentComponent; 【实现2】12345678910111213141516171819202122232425262728293031323334353637383940let captcha = null;const Captcha = () =&gt; &#123; const [show, setShow] = useState(false); const captchaRef = useRef(null); useImperativeHandle(captchaRef, () =&gt; (&#123; show() &#123; setShow(true); // 暴露 show 方法 &#125;, hide() &#123; setShow(false);// 暴露 hide 方法 &#125; &#125;)); useEffect(() =&gt; &#123; captcha = &#123; show: () =&gt; &#123; captchaRef.current.show(); // 暴露 show 方法 &#125;, hide: () =&gt; &#123; captchaRef.current.hide(); // 暴露 hide 方法 &#125; &#125;; return () =&gt; &#123; captcha = null; &#125;; &#125;, []); return ( show &amp;&amp; &lt;div className=\"captcha-b\" ref=&#123;captchaRef&#125;&gt;&lt;/div&gt; );&#125;;export &#123; Captcha, captcha&#125;; 【总结】useImperativeHandle 是 React 中用于自定义暴露给父组件的实例值的 hook，它可以让子组件暴露给父组件方法，使得父组件可以直接调用子组件的方法。把组件挂载在根节点上，可以通过暴露出来的方法去调用。例上述方法2中，在引入captcha后，可以在组件需要的时机执行captcha.show()、captcha.hide() 方法，实现调用。","pubDate":"Fri, 16 Aug 2024 07:27:44 GMT","guid":"https://chinalijinglun.github.io/2024/08/16/react中useImperativeHandle的使用/","category":"react开发"},{"title":"css实现中间内容撑开头尾效果","link":"https://chinalijinglun.github.io/2024/08/16/css实现中间内容撑开头尾效果/","description":"【引言】最近在做一个网站，需要实现一个中间内容撑开头尾效果，本来想用本办法定位的方式去做，但是发现能实现效果但是太麻烦了，最终经过参考与实践通过flex布局的方式去实现更为简单，同时grid布局也可以实现，下面附上代码。【实现效果】 flex 实现效果：div结构如下12345&lt;div class=\"container\"&gt; &lt;div class=\"header\"&gt;头部&lt;/div&gt; &lt;div class=\"content\"&gt;内容&lt;/div&gt; &lt;div class=\"footer\"&gt;尾部&lt;/div&gt;&lt;/div&gt; container的css如下:12345678910111213141516.container &#123; display: flex; flex-direction: column; justify-content: space-between; margin: 0 auto; min-height: 100%; width: 100%;&#125;.header, .footer &#123; background: #fff; width: 100%;&#125;.content &#123; flex: 1; // 这行代码使得content占据剩余的空间 background: #f0f0f0;&#125; grid 实现效果：div 结构如上css如下:1234567891011121314151617.container &#123; display: grid; grid-template-rows: auto 1fr auto; // 设置高度 height: 100vh;&#125;.header, .footer &#123; background-color: #f1f1f1; padding: 20px; text-align: center;&#125;.content &#123; background-color: #e2e2e2; padding: 20px; text-align: center;&#125;","pubDate":"Fri, 16 Aug 2024 06:45:01 GMT","guid":"https://chinalijinglun.github.io/2024/08/16/css实现中间内容撑开头尾效果/","category":"Web开发"},{"title":"实现一个chatgpt的网站","link":"https://chinalijinglun.github.io/2023/08/25/实现一个chatgpt的网站/","description":"【引言】由于前一段时间离职，处在一个gap期间，每天不是投简历就是刷题看剧陪娃，挺无聊的，无聊刷到一些技术文章，看都在推广自己的chatgpt相关的网站，我想不如自己也弄一个吧！方便自己和他人。【前期准备】 [x] chatgpt开通api服务 [x] 云服务器 [x] 短信服务 [x] 域名 上面准备工作中，只有开通chatgpt的api算是最高难度的了，国内visa信用卡还不支持，就算是国外也不是所有的信用卡都支持，因此网上有一些虚拟信用卡的开通服务，但是也要慎用。我是找了美国的朋友，用他的信用卡开通。 【最终效果】【遇到的问题】 EventSource 请求返回拼接遇到空格和特殊字符的问题 打字机效果在服务器不显示 markdown转换效果不理想 【解决方案】 服务端返回的格式多为：123456789data:id:retry:event:data:id:retry:event: 有些字段会有换行符和特殊字符，这些字符如何直接格式化后拼接会报错，这种在返回代码中最为明显，所以在返回到了前端处理的时候，要处理一下，我是这么做的，如果可以直接JSON.parse的话，那么就正常取值，如果JSON.parse报错的话，手动截取引号中间的内容返回。 1234567891011121314151617181920212223242526272829const newReg = (str: string) =&gt; &#123; let data = ''; const lines = str.split('\\n\\n'); const jsonObj = isJSON(str); if (jsonObj) &#123; const &#123; message &#125; = JSON.parse(str); if (message === \"余额不足\") &#123; data = `[$&#123;message&#125;, 请充值](/?recharge=true)`; &#125; else &#123; data = message; &#125; &#125; else &#123; for (let i = 0; i &lt; lines.length; i++) &#123; const line = lines[i].trim(); const jsonString = line.substring(5); // 去掉开头的 \"data:\" try &#123; const obj = JSON.parse(jsonString); data += obj['content']; &#125; catch (e) &#123; const parsedObj = jsonString.slice(12, -2); data += parsedObj; &#125; &#125; &#125; return data;&#125; 打字机效果是文字一个一个出现的效果，这个效果在本地显示的好好的，但是服务器怎么都不显示，在google和github查了很多资料后，终于找到了是因为服务器的nginx的配置导致的，需要更改nginx.config配置。 123proxy_cache off; # 关闭缓存proxy_buffering off; # 关闭响应缓存,最主要的代码chunked_transfer_encoding on; # 开启分块传输编码 markdown这个确实是需要自己去处理返回的代码的语言类型，语言内容，我用的是MarkdownIt这个插件，具体实现如下 123456789101112131415161718mdi.renderer.rules.code_inline = function (tokens, idx, options, env, slf) &#123; var token = tokens[idx]; if(token.markup == \"```\")&#123; var newlineIndex = token.content.indexOf('\\\\n'), language = token.content.slice(0, newlineIndex), content = token.content.slice(newlineIndex+2,token.content.length).replace(/\\\\n/g, '\\n').replace(/\\\\/g, ''); // console.log(content) const validLang = !!(language &amp;&amp; hljs.getLanguage(language)) if (validLang) &#123; const lang = language ?? '' return highlightBlock(hljs.highlight(content, &#123; language: lang &#125;).value, lang, content) &#125; return highlightBlock(hljs.highlightAuto(content).value, '', content) &#125;else&#123; return `&lt;code class=\"hljs code-block-body js\" &gt;$&#123;token.content&#125;&lt;/code&gt;` &#125;&#125;; 【结束】后期还是想接入一下Midjourney的api，并且后端重新使用Nodejs实现一遍；最后还是放一下链接，欢迎大家注册试玩。Ailin智能聊天机器人","pubDate":"Fri, 25 Aug 2023 03:20:06 GMT","guid":"https://chinalijinglun.github.io/2023/08/25/实现一个chatgpt的网站/","category":"Web开发"},{"title":"bpmn.js 使用总结","link":"https://chinalijinglun.github.io/2023/05/19/bpmn-js-使用总结/","description":"【引言】最近一段时间的工作重点在审批流和低代码平台，审批流的话，最开始是使用 Bpmn.js 去构建前端的流程图；使用了一段时间后，也算是得心应手，踩过很多坑，也淌平了很多恶心的需求吧，趁此机会总结一下。 基本上 bpmn 原有的元素从 UI 到功能上面都会有所更改，从左侧元素工具栏到中间的元素，连接线，元素的面板，基本上都要重新覆盖。 最终效果如下： 【正文】 任务节点更换皮肤后，文字不显示或者文字不居中问题最开始想到的解决办法是手动处理每个sharp的样式，手动把 x,y,font-size,fill 给填上，这么做虽然可行，但是每个sharp的坐标，位置，大小，文字长度都得计算，觉得这并不是一个好方案，然后翻阅了 bpmn.js 的源码，看了他的实现，觉得可以在自定义这块重新在调用就可以了，实现如下代码: 12345678910111213141516171819202122232425262728293031import TextUtil from 'diagram-js/lib/util/Text.js';import &#123; assign &#125; from 'min-dash';const defaultStyle = assign(&#123; fontFamily: 'Arial, sans-serif', fontSize: 12, fontWeight: 'normal', lineHeight: 1.2&#125;);const textUtil = new TextUtil(&#123; style: defaultStyle&#125;);const elementStyle = &#123; size: &#123; \"width\": 100 &#125;, box: &#123; \"width\": 100, \"height\": 80, \"type\": \"bpmn:Task\", &#125;, align: \"center-middle\", padding: 5, style: &#123; \"fill\": \"black\" &#125;&#125;const text = textUtil.createText(element.businessObject.name, elementStyle);svgAppend(parentNode, text);return text; 分支箭头更换皮肤后，箭头不变化监听bpmnModeler变化时，执行如下代码即可12345678910111213141516171819202122232425setArrowColor() &#123; const marker = svgCreate('marker') svgAttr(marker, &#123; id: 'sequenceflow-arrow-normal', viewBox: '0 0 20 20', refX: '11', refY: '10', markerWidth: '10', markerHeight: '10', orient: 'auto' &#125;) const path = svgCreate('path') svgAttr(path, &#123; d: 'M 1 5 L 11 10 L 1 15 Z', style: ' stroke-width: 1px; stroke-linecap: round; stroke-dasharray: 10000, 1; ' &#125;) const defs = domQuery('defs') svgAppend(marker, path) svgAppend(defs, marker)&#125; 12345678910#sequenceflow-arrow-normal &#123; fill: #ACC2FF !important; stroke: #ACC2FF !important;&#125;.djs-connection &#123; path &#123; stroke: #ACC2FF !important; marker-end: url(#sequenceflow-arrow-normal) !important; &#125;&#125; 一些元素的显隐问题因为 bpmn.js 是通过svg实现图形功能的，所以简单的是绝大部分的元素的隐藏都可以通过 css 来处理，只有少部分需要自行操作svg的属性。 svg的添加、删除、增加属性等功能可以使用内置的tiny-svg这个库来解决，结合min-dom和min-dash其实能解决好多关于svg的问题，都是一些很简单也很好用的库，地址： tiny-svg 【结束】总的来说，学习和使用 bpmn.js 虽然看上去有一定的难度，但其实多尝试，就能够掌握这个工具，并且可以在其中实现自己的需求。网上的相关资料、源码以及API接口都比较详细，并且开发者的社区也非常活跃，所以我们可以尝试寻找适合自己的解决方案，并且不断尝试和探索最佳的使用方式和技巧。","pubDate":"Fri, 19 May 2023 02:33:23 GMT","guid":"https://chinalijinglun.github.io/2023/05/19/bpmn-js-使用总结/","category":"Web开发"},{"title":"独立域名项目改造为单域名项目","link":"https://chinalijinglun.github.io/2023/05/15/独立域名项目改造为单域名项目/","description":"一 起因公司项目要给客户独立部署，原来的项目的域名为：12a.xxx.com/b.xxx.com/ 改成为12xxx.com/a/xxx.com/b/ 总结一下更改的过程及内容 二 路由改动vue路由增加base，react路由增加basename12345678new Router(&#123; mode: 'history', saveScrollPosition: true, scrollBehavior: () =&gt; (&#123; y: 0 &#125;), base: window.env.staticPath,&#125;) 123export const globalHistory = createBrowserHistory(&#123; basename: window.env.staticPath&#125;) 三 打包路径改动vue的话，看cli的版本，但是变化不大，基本上都是publicPath，react的话，如果是create-react-app就是homepage，其余的框架本身也是类似publicPath。12345output: &#123; path: webpackConfigBase.resolve('dist'), publicPath: '/__PUBLIC_PATH_PLACEHOLDER__/', filename: 'static/js/[name].[chunkhash:8].js'&#125;, 1\"homepage\": \"/__PUBLIC_PATH_PLACEHOLDER__\", 四 多环境部署问题上面代码中，其实我们使用了大量的变量或者标识，因为我们一个项目会部署到很多环境上面，最开始的想法是在package.json中新建很多script命令，去一一执行，但是太多了，而且你还得每次改Jenkins的打包命令，索性的是每次独立部署每个项目都要重新配置对应的docker-compose.yml文件，那么就想到了，通过docker配置去保存当前环境、打包、目录路径等内容，然后通过shell脚本去替换变量就好了。ps: 环境部署还是得看公司整体的解决方案才行。 12345678910111213141516171819run.sh 文件sed -i \"s|/__PUBLIC_PATH_PLACEHOLDER__|$BOOT_PUBLIC_PATH|g\" /usr/share/nginx/html/*.htmlsed -i \"s|/__PUBLIC_PATH_PLACEHOLDER__|$BOOT_PUBLIC_PATH|g\" /usr/share/nginx/html/static/css/*.csssed -i \"s|/__PUBLIC_PATH_PLACEHOLDER__|$BOOT_PUBLIC_PATH|g\" /usr/share/nginx/html/static/js/*.jsexec nginx -g 'daemon off;'在Dockerfile中 执行上面的脚本CMD [\"run.sh\"]最后在docker-compose.yml文件中，更改对应的路径及配置environment: - NGINX_PORT=10021 - XST_DOMAIN= - TZ=Asia/Shanghai - BOOT_PUBLIC_PATH=https://xxx.com/","pubDate":"Mon, 15 May 2023 09:39:59 GMT","guid":"https://chinalijinglun.github.io/2023/05/15/独立域名项目改造为单域名项目/","category":"Web开发"},{"title":"一个中年人的记录","link":"https://chinalijinglun.github.io/2023/03/08/一个中年人的自白/","description":"一 都说三十而立，过了而立之年就应该有所成就，承担责任，能够有明确的人事目标和方向；我来讲讲我的现状，用两个字概括的话，就是焦虑；焦虑充斥在家庭，工作，生活之中，甚至一度导致我有点抑郁，因为看不到未来，看不到希望，有时候觉得天都是灰色的，有很多烦恼，压力无处去发泄，心态严重的失衡，也证明了我并不是一个内心强大的人，当闭上眼睛脑海里面浮现的都是孩子的教育，孩子的未来，我的工作，我的工资等等，都是一些自己无能为力但是又不停内耗的事。 二 没读过万卷书，也没行过万里路，一个普通人，去过的地方屈指可数，一直想真正的潇洒一下，来一场说走就走的旅行，希望能带着我儿子，去看看祖国的大好河山，让他感受一下生活以外的地方是什么样，也增加和孩子的相处时间。 这几年看的书也丰富了起来，不在局限于文学、技术类的，也会看看地理、哲学、经济一类的，希望自己能够保持阅读的习惯，丰富自己的灵魂。 三 觉得自己有很多可以改进的地方，比如：沟通，懒惰，耐心，逻辑思维的完善性；觉得自己随着年龄增长，也多了几分不可理喻和放纵，不想去思考，也懒得去思考，后来想想，觉得这是一种逃避现实的方法，百害而无一利；觉得自己虽然面对电脑的时间比面对人的时间还多，但是也不能忘了沟通的重要性，多看一些关于沟通相关的书籍和视频，更重要的是多实战吧。 结尾 正视自己，不要逃避，保持良好情绪，适当发泄情绪；不想就这么过完一生；共勉。","pubDate":"Wed, 08 Mar 2023 08:37:51 GMT","guid":"https://chinalijinglun.github.io/2023/03/08/一个中年人的自白/","category":"随笔"},{"title":"聊聊前端优化","link":"https://chinalijinglun.github.io/2023/02/24/聊聊前端优化/","description":"随着互联网技术的发展，网页已经不再是简单的静态文档，而是变成了功能丰富、交互复杂、视觉精美的应用程序。然而，这些应用程序也带来了一个挑战：如何在保证功能和体验的同时，让网页快速加载并运行？这就是前端性能优化要解决的问题。 前端性能优化是一门综合性很强的学科，它涉及到网络、浏览器、JavaScript、CSS、HTML、图片等多个方面。为了达到最佳效果，我们需要从多个角度出发，采用各种技巧和工具来分析、测试、监控和改进网页的性能。 本文旨在提供一份全面而实用的前端性能优化指南。（本段文字来自chatGPT生成） 以上来自雅虎优化指南，也叫雅虎军规。 服务端篇 Content Delivery Network（CDN） cdn具有能提高网站的访问速度、节省带宽等优势，其工作原理是通过将源站的内容缓存到分布在不同地区和运营商的边缘节点上，当用户请求时，就近返回节点上缓存的内容。cdn还涉及DNS解析、负载均衡、内容分发、调度等技术模块。 浏览器缓存 缓存的设置可以大大提高响应速度，减少http请求，节省带宽等优势，缓存包括强缓存、协商缓存等，可以添加Expires头，配置ETag等属性来选择缓存的方式。当浏览器请求一个资源时，它会检测本地缓存中是否有该资源，并且是否在有效期内，如果是，则直接从本地缓存中返回该资源。 强缓存是利用HTTP请求头中的Expires和Cache-Control 两个字段来进行控制，用来表示资源的缓存时间，Expires是一个绝对时间，Cache-Control 是一个相对时间，表示资源在多长时间内有效；一般会对js、css、图片等资源使用强缓存。 协商缓存是利用 HTTP 请求头中的 Last-Modified/If-Modified-Since 和 ETag/If-None-Match 两对字段来进行控制，用来表示资源的更新时间和唯一标识。 当浏览器再次请求一个资源时，如果本地缓存已经过期，它会携带这些字段向服务器发送请求，询问资源是否有更新。如果没有更新，则服务器会返回 304 状态码，告诉浏览器可以继续使用本地缓存。如果有更新，则服务器会返回 200 状态码和新的资源，并更新本地缓存。 AppCache 在html页面中指定manifest文件的路径，例如&lt;html manifest=&quot;example.appcache&quot;&gt; 在manifest文件中列出需要缓存的资源，以及在离线时显示的页面，例如： 1234567891011121314CACHE MANIFEST# v1.0.0CACHE:index.htmlstyle.cssscript.jslogo.pngNETWORK:*FALLBACK:/ offline.html 在服务器端配置正确的MIME类型，例如text/cache-manifest 在浏览器中访问html页面，浏览器会自动下载并缓存manifest文件中指定的资源 在离线时，浏览器会从缓存中加载资源，并在无法访问的情况下显示fallback页面 Localstorge、Sessionstorage、Cookie、CacheStorage 用于本地存储，常用，不必过多解释。 减少请求数 小图片合并雪碧图； 避免重复的资源请求。减少请求数 减少文件大小，节省请求带宽 压缩CSS、JS、图片； 尽可能控制DOM节点数； 精简css、 JavaScript，移除注释、空格、重复css和脚本。 开启Gzip，Gzip的思想就是把文件先在服务器端进行压缩，且压缩率达到85%，然后再传输，传输完毕后浏览器会重新对压缩过的内容进行解压缩，并执行。。好处在于Gzip的支持已经很好，且爬虫可识别，压缩率达到66%-85%显著减少了文件传输的大小。另外，gzip对pdf文件的压缩效果不大，而且会浪费CPU。 静态资源域名 域名的要求一般是独立短小，短小可以减少头部开销，域名越短请求头的URI就越短；独立是因为独立的域名不会共享主域的cookie，可以减少请求头大小，还有一个原因是浏览器对相同域名的并发连接数是有限制的，一般同域名为6-8个连接，当然域名不是越多越好，每个域名的第一次连接都要经理DNS查询，会耗费时间，尽量控制域名在2-4个间，需要注意的是，同一静态资源在不同页面散列到不同子域下，会导致无法利用http缓存。 http2（来源：baidu.com） 多路复用：多路复用很好地解决如何让重要资源尽快加载这个问题。同域名下或者不同域但是同时满足同一个 IP以及使用同一个证书的这两个条件中的所有通信都在单个连接上完成，此连接上同时打开任意数量的双向数据流（ HTTP 1.1 有连接数限制）。使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。（来源：baidu.com） HEAD压缩：HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码（ Binary Framing ）。在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成，状态行和头部却没有经过任何压缩，直接以纯文本传输。在 HTTP/2 中，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。 请求优先级：服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。 服务器推送：启动Server Push，意味着服务端可以在发送页面HTML时主动推送其它资源，有自己独立的URL，可以被浏览器缓存；如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。 客户端篇 使用外链CSS和JS，CSS放头，JS放尾，防止阻塞以减少对并发下载的影响，尽早刷新文档的输出。 html的代码优化，如： 避免空的图片src； 协议自适应，减少html文件大小，将https://和http://都替换成//。 css的代码优化，如： 建议使用类选择器，访问比较快； 不建议使用很长的base64； 避免CSS表达式； 避免使用Filters。 js的代码优化，如： 避免使用eval和width； 减少作用域链查找； 减少DOM访问，尽量缓存DOM； 充分利用事件委托； 减少Repaint（重绘）和Reflow（重排）最好通过批量更新元素减少重排次数，如设置类class统一更新样式，在添加多个li 元素将会触发多次页面重排的情况下使用 DOM fargment 在内存中创建完整的 DOM 节点，然后再一次性添加到 DOM 中。 图片格式的选择： 颜色较为丰富的图片而且文件比较大的（40KB - 200KB）或者有内容的图片优先考虑 jpg；图标等颜色比较简单、文件体积不大、起修饰作用的图片，优先考虑使用 PNG8 格式；图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式。 条件允许的，使用新格式WEBP和BPG。 用SVG和ICONFONT代替简单的图标。 合理分配资源加载时间，按需加载，包括CSS、JS文件以及图片、业务模块等。 根据我们网页最初加载需要的最小内容集推断其他内容延迟加载；无条件提前加载公共内容或根据用户行为推断提前加载某些内容，如根据搜索框输入的文字来判断加载的内容。加载机制如下： 预加载 Dom Ready后加载 onLoad后加载 滚动加载 减少DNS 查询：DNS 查询一般需要几毫秒到几百毫秒，移动环境下会更慢。我们可以预先读取DNS，减少用户等待时间。 更多代码规范相关，请参考： 前端代码规范","pubDate":"Fri, 24 Feb 2023 07:43:35 GMT","guid":"https://chinalijinglun.github.io/2023/02/24/聊聊前端优化/","category":"性能优化"},{"title":"antd中表单自定义组件如何获取值","link":"https://chinalijinglun.github.io/2023/02/22/表单自定义组件/","description":"页面中有大量的form表单，但是不是所有的自定义表单都能满足我们的需求，很有可能需要自定义组件去解决问题，那么自定义组件如何获取antd的value值呢？12345678910111213141516171819202122232425262728import &#123; Form, Input &#125; from 'antd';import &#123; useEffect &#125; from 'react'; const App = () =&gt; &#123; const [form]= Form.useForm(); useEffect(() =&gt; &#123; form.setFieldsValue(&#123; a: &#123; b: &#123; c: 'ccc' &#125; &#125;, d: &#123; e : 'eee' &#125; &#125;) &#125;, []); return ( &lt;Form form=&#123;form&#125;&gt; &lt;Form.Item name=&#123;['d', 'e']&#125;&gt; &lt;Input/&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )&#125;export default App; 这代码熟悉吧！是不是经常写？ 这是 antd 的 Form 组件的用法： 通过 useForm 拿到 form 对象，设置到 Form 组件里，然后用 form.setFieldsValue 设置的字段值就能在 Form.Item 里取到。 Form.Item 只需要在 name 里填写字段所在的路径就行，也就是 [‘d’, ‘e’] 这个。 有的同学可能会问了，为啥这里只设置了个 name，它下面的 Input 就有值了呢？ 我们让 Form.Item 渲染一个自定义的组件试一下，比如这样： 12345const MyInput = (props) =&gt;&#123; return &lt;div&gt; &lt;Input&gt; &lt;/div&gt; &#125; 1234567return ( &lt;Form form=&#123;form&#125;&gt; &lt;Form.Item name=&#123;['d', 'e']&#125;&gt; &lt;MyInput/&gt; &lt;/Form.Item&gt; &lt;/Form&gt;) 通过给自定义组件打断点，可以看到，组件内部传入了 id、value、onChange 等参数进来， 这就是为啥 Input 能有值，因为传入了 value 参数。 而且变化了也能同步到 fields，因为传入了 onChange 参数。 有的时候我们要对保存的值做一些修改，就可以这样写： 12345678function MyInput(props) &#123; const &#123; value, onChange &#125; = props; console.log(form.getFieldsValue()) function onValueChange(event) &#123; onChange(event.target.value.toUpperCase()); &#125; return &lt;Input value=&#123;value&#125; onChange=&#123;onValueChange&#125;&gt;&lt;/Input&gt;&#125; 所以说，Form.Item 会给子组件传入 value、onChange 参数用来设置值和接受值的改变，同步到 form 的 fields。 以下是我个人经常使用的上传图片的组件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; useEffect, useState &#125; from 'react'import &#123; message, Upload &#125; from \"antd\";import &#123; LoadingOutlined, PlusOutlined &#125; from \"@ant-design/icons\";const defaultUrl = \"\"const imageURL = \"\"const UploadImg = (props: any) =&gt; &#123; const &#123;value, onChange&#125; = props; const [loading, setLoading] = useState(false); const handleChange = (info: any) =&gt; &#123; if (info.file.status === \"uploading\") &#123; setLoading(true); return; &#125; if (info.file.status === \"done\") &#123; const url = info.file.response.data.url; onChange &amp;&amp; onChange(url); setLoading(false); &#125; &#125;; const beforeUpload = (file: any) =&gt; &#123; const isJpgOrPng = file.type === \"image/jpeg\" || file.type === \"image/png\"; if (!isJpgOrPng) &#123; message.error(\"只支持 JPG/PNG 文件!\"); &#125; const isLt2M = file.size / 1024 / 1024 &lt; 5; if (!isLt2M) &#123; message.error(\"图片必须小于5MB!\") &#125; return isJpgOrPng &amp;&amp; isLt2M; &#125;; return ( &lt;Upload name=\"file\" // customRequest=&#123;customRequest&#125; listType=\"picture-card\" className=\"avatar-uploader\" showUploadList=&#123;false&#125; action=&#123;defaultUrl&#125; beforeUpload=&#123;beforeUpload&#125; onChange=&#123;handleChange&#125; &gt; &#123;value ? ( &lt;img src=&#123;imageURL + value&#125; alt=\"avatar\" style=&#123;&#123; width: \"100%\" &#125;&#125; /&gt; ) : ( &lt;div&gt; &#123;loading ? &lt;LoadingOutlined /&gt; : &lt;PlusOutlined /&gt;&#125; &lt;div style=&#123;&#123; marginTop: 8 &#125;&#125;&gt;点击上传&lt;/div&gt; &lt;/div&gt; )&#125; &lt;/Upload&gt; )&#125;export default UploadImg","pubDate":"Wed, 22 Feb 2023 07:43:35 GMT","guid":"https://chinalijinglun.github.io/2023/02/22/表单自定义组件/","category":"react开发"},{"title":"Phaser游戏开发2","link":"https://chinalijinglun.github.io/2018/05/03/Phaser游戏开发2/","description":"Phaser游戏开发2； 上面的代码已经完成了80%的内容，下面让我们来继续完善游戏内容； 碰撞检测1game.physics.arcade.collide(player, platforms); Phaser.Physics.arcade.collide(object1, object2, collideCallback, processCallback, callbackContext) 参数分别为，对象1，对象2，碰撞回调函数，比如有的关卡，有陷阱一类的，人物要是碰撞后，在回调中kill人物，state跳到over上。 重叠检测跟碰撞类似，只是api不同1game.physics.arcade.overlap(player, platforms); Phaser.Physics.arcade.overlap(object1, object2, collideCallback, processCallback, callbackContext) 多用在获得道具上，比如人物和星星重叠后，可以加分，然后消除星星。 12345game.physics.arcade.overlap(player,stars,function (player,star) &#123; scroe += 10; fonts.text = 'scroe: ' + scroe; star.kill();&#125;) 上下左右操作1cursors = game.input.keyboard.createCursorKeys(); Phaser.Game.input.keyboard.createCursorKeys() 1234567891011if(cursors.left.isDown)&#123; player.body.velocity.x = -150; player.animations.play('left');&#125;else if(cursors.right.isDown)&#123; player.body.velocity.x = 150; player.animations.play('right');&#125;else&#123; player.frame = 4; player.body.velocity.x = 0; player.animations.stop();&#125; 当按下键盘 &lt;- 左键时，x轴加速为-150，然后执行animations的left动画，有一点是需要注意的是，在没有按下左右键的时候，让frame定格在第4帧，1player.frame = 4; 以下为全部代码：Phaser 小游戏About。","pubDate":"Thu, 03 May 2018 07:45:09 GMT","guid":"https://chinalijinglun.github.io/2018/05/03/Phaser游戏开发2/","category":"游戏开发"},{"title":"Phaser游戏开发1","link":"https://chinalijinglun.github.io/2018/04/27/Phaser游戏开发/","description":"最近开发基于微信分享的h5小游戏，之前试用createJs，觉得想换个游戏引擎试试，所以找到了Phaser，基于pixi，内置了物理引擎，动画等。 初始化123456789var game = new Phaser.Game(288,505,Phaser.AUTO,'game',state); var game = new Phaser.Game(288,505,Phaser.AUTO,'game',&#123;proload:proload,create:create&#125;);Phaser.Game(width, height, renderer, parent, state, transparent, antialias, physicsConfig)width: 游戏场景的宽度，单位为pxheight: 高度，renderer: 渲染方式，有Phaser.CANVAS，Phaser.WebGL，Phaser.AUTO，auto是自动识别parent: 用来放置canvas元素的父元素，可以是一个元素id，也可以是dom元素本身，phaser会自动创建一个canvas并插入到这个元素中state: 场景，通常会有（init，proload，create，update等） state 是一个场景，可以是一个对象，也可以是一个构造函数，只要存在proload、create、update中的一个，就是一个合法的state； 1234567891011121314151617181920//state可以是一个自定义对象var state1 = &#123; preload : function()&#123; &#125;, create : function()&#123; &#125;, update : function()&#123; &#125; &#125;//state也可以是一个构造函数var state2 = function()&#123; this.preload = function()&#123; &#125;; this.create = function()&#123; &#125;; this.update = function()&#123; &#125;;&#125;//state里面可以存在其他的方法，和属性//state里面只要存一个proload、create、update中一个即可var state3 = function()&#123; this.aaa = function()&#123;&#125;; this.bbb = 'first'; this.create=function()&#123;&#125;&#125; 加载资源proload函数是最先执行的，用来加载资源、create是初始化场景的函数，等proload执行完成后执行，update是更新函数，游戏每一帧都要执行update； 12345678910function state() &#123; //加载资源 this.preload = function () &#123; // load img and 精灵 game.load.image(&quot;sky&quot;, &apos;assets/sky.png&apos;); game.load.image(&quot;platform&quot;, &apos;assets/platform.png&apos;); game.load.image(&quot;star&quot;, &apos;assets/star.png&apos;); game.load.spritesheet(&apos;dude&apos;, &quot;assets/dude.png&quot;, 32, 48); &#125;&#125; 使用方法为:game.load.’资源’(‘别名’,’路径’)；常用的资源有：image、audio、tilemap、text、spritesheet；别名指后面用的名称；其中spritesheet还需要添加每帧的宽高帧数等。 初始界面资源加载完成后，会自动进入create函数123this.create = function () &#123; game.add.sprite(0,0,'sky')&#125; sprite对象，也叫精灵，可以用图片来创建精灵，然后用phaser提供的属性，来操作。1game.add.sprite(0,0,'sky') 创建后，会自动添加对应的内容在主界面。说一个比较重要的对象：Phaser.group(),也就是组，相当于一个统一一个父容器，把需要的子对象放进去，然后可以通过组的方法进行批量的操作，比如统一的位移和碰撞检测等。12345platforms = game.add.group();var ground = platforms.create(0,0,'platform');var ledge = platforms.create(400,200,'platform'); 物理引擎Phaser已支持一些不同的物理系统，有Arcade Physics,，Ninja Physics 和 P2.JS Full-Body Physics。对与简单的物理方法，我们使用Arcade Physics即可。物理引擎在Phaser中是默认关闭的，要启用可以在create中使用：1game.physics.startSystem(Phaser.Physics.ARCADE); 要启用整组的物理属性，使用enableBody即可1platforms.enableBody = true; 开启物理属性后，即可得到一个body属性，所有的物理属性方法都挂在body上面常用的属性有：immovable、bounce、gravity、drag、sprite、x、y、collideWorldBounds、input等，对应各种固定，弹性、重力，拖拽，边界等。 12ground.body.immovable = true;legs.body.immovable = true; 12player.animations.add(&apos;left&apos;, [0, 1, 2, 3], 10, true);player.animations.add(&apos;right&apos;, [5, 6, 7, 8], 10, true); TileSprite、Rope、Image、Button、Sprite等拥有animations属性，可以添加动画方法1Phaser.Sprite.animations.add(name, frames, frameRate, loop, useNumericIndex) 分别为动画名称，帧数数组，每秒帧数，循环次数； 添加文字1game.add.text(10,10,'score:0',&#123; font: \"35px Arial\", fill: \"#ff0044\"&#125;) //Phaser.Game.add.text(x, y, text, style, group);如果你经常使用canvas的话，对这种应该不陌生，分别为：x、y、文字内容，样式组。 这样我们基本完成了create函数的内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748this.create=function () &#123; //开启物理引擎 game.physics.startSystem(Phaser.Physics.ARCADE); //添加天空 game.add.sprite(0, 0, 'sky'); //添加地板组 platforms = game.add.group(); //开启地板组的物理属性 platforms.enableBody = true; //添加底部地板 var grounds = platforms.create(0,game.world.height-32,'platform'); //设置缩放 grounds.scale.setTo(2,1); //禁止移动 grounds.body.immovable = true; var legs = platforms.create(-150,120,'platform'); legs.body.immovable = true; legs = platforms.create(400,270,'platform'); legs.body.immovable = true; //添加人物 player = game.add.sprite(32, 150, 'dude'); game.physics.arcade.enable(player); player.body.bounce.y = 0.3; player.body.gravity.y = 500; player.body.collideWorldBounds = true; player.animations.add('left', [0, 1, 2, 3], 10, true); player.animations.add('right', [5, 6, 7, 8], 10, true); cursors = game.input.keyboard.createCursorKeys(); //添加文字 fonts = game.add.text(10,10,'score:0',&#123; font: \"35px Arial\", fill: \"#ff0044\"&#125;) //添加星星 stars = game.add.group(); stars.enableBody = true; for(var i =0;i&lt;12;i++)&#123; var star = stars.create(i * 70 , 0, 'star'); star.body.bounce.y = 0.7; star.body.gravity.y = 400; star.body.collideWorldBounds = true; &#125; &#125;","pubDate":"Fri, 27 Apr 2018 09:06:30 GMT","guid":"https://chinalijinglun.github.io/2018/04/27/Phaser游戏开发/","category":"游戏开发"},{"title":"iTerm2 免密登录 SSH 的方法","link":"https://chinalijinglun.github.io/2018/04/27/登录/","description":"大家都知道使用iTerm2连接shh 使用命令 ssh -p22 root@129.10.10.1，然后输入密码即可。但是对于我们的服务器或者测试服务器，每次都这么手动ssh连接太慢了而且麻烦，我们可以考虑使用比较快捷的方式去连接的。 1、在~/.ssh下，新建文件，比如login，或者test1等；2、1234567891011#!/usr/bin/expect -fset user rootset host 192.168.1.109set password test123###set timeout -1spawn ssh $user@$hostexpect \"*assword:*\"send \"$password\\r\"interactexpect eof 3、如果是其他的端口，在set一个port xxxx，xxxx对应你的端口；4、打开iterm2的Profiles，点击+号，新增一个profile，name写自己连接主机的名称，然后在command上选择command，把：1expect ~/.ssh/login 后面的login对应你建立的文件名称5、使用的时候，直接在iterm2上面的Profiles选择你填写的用户名即可。","pubDate":"Fri, 27 Apr 2018 06:50:59 GMT","guid":"https://chinalijinglun.github.io/2018/04/27/登录/","category":"Web开发"},{"title":"新年新展望","link":"https://chinalijinglun.github.io/2018/01/15/新年新展望/","description":"“又是一年芳草绿,春风十里杏花香”总结一下去年的自己，去年自己算是挺圆满的了，结了个婚，换了份工作，虽然不是什么大人物，但是小人物也有小人物的幸福，挺知足的。去年自己成功的把vueJs引入上家公司，并完成了前后端的完全分离，极大的解放了生产力和提高了效率，并使得公司绝大部分人都学习了vue及nodejs，并使用vue开发了3、4个大型的项目，对vue也算是从熟悉到理解，并能够把element-ui中的组件重写或者更改；项目中也使用了很多ES6的语法，对ES6也算是很熟悉了吧。看了将近20本左右的书籍，其中文学读物（金庸、古龙、梁羽生、四大名著、网络小说）占比一半，技术书籍（js、python、nodejs、css）占一半，总体来说，看书的收获还是挺大的，希望自己有一天也能出书。 又是一年的开始，做个今年的计划吧！1、写完自己的vueUI组件，传说中的Lui，哈哈2、写go程序或者python，毕竟很久没写了3、写一款自己的小游戏4、精通typescript5、看完10左右的技术书籍","pubDate":"Mon, 15 Jan 2018 07:12:32 GMT","guid":"https://chinalijinglun.github.io/2018/01/15/新年新展望/","category":"随笔"},{"title":"canvas压缩图片","link":"https://chinalijinglun.github.io/2017/08/06/canvas压缩图片/","description":"最近遇到了图片压缩的问题，想在前端控制一下，所以有了一下代码。","pubDate":"Sun, 06 Aug 2017 10:45:41 GMT","guid":"https://chinalijinglun.github.io/2017/08/06/canvas压缩图片/","category":"Web开发"},{"title":"chrome下调试小技巧（一）","link":"https://chinalijinglun.github.io/2017/07/24/chrome_1/","description":"chrome下调试小技巧（一） 1、快速格式化线上压缩的js和css我们通常看线上的js或者css都是这样的 通过在sources下的{}，点击即可格式化代码很方便 2、在浏览器中储存你的代码段其实chrome中也是可以储存我们自己的代码的，如果不想每次都粘贴在控制台中或者临时想写些什么，那么sources中的Sinppets将是你的一个很好的选择，Sinppets中你可以新建很多个不同的代码段，跟文本一样，可以写一些文字或者代码，可以command+s保存，如果你写的是js代码一类的，可以直接右键你的Sinppets文件名称，点击Run，即可执行你的代码，也可以右键文件Save as保存文件到本地。 3、快速定位到指定的文件或者文件中的方法ctrl+p 项目中定位文件，以下查找VueJS库文件：ctrl+shif+o 文件中定位成员函数，以下定位到VueJS的nextTick接口： 暂且写这么多，network及短点什么的，估计大家都会用了，就不介绍了。","pubDate":"Mon, 24 Jul 2017 09:52:37 GMT","guid":"https://chinalijinglun.github.io/2017/07/24/chrome_1/","category":"移动开发"},{"title":"Hello World","link":"https://chinalijinglun.github.io/2015/10/08/hello-world/","description":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Thu, 08 Oct 2015 02:24:35 GMT","guid":"https://chinalijinglun.github.io/2015/10/08/hello-world/","category":"Web开发"}]}